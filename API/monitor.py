"""Class DataMonitor handles acquiring all in game data relevant for the deck tracker"""
import sys
import riot_requests as api
import psutil
import _thread
import re
import time
import os

class DataMonitor():
	def __init__(self):
		self.gameState = None
		self.deck = None
		self.hand = None
		self.logPath = None
		self.appRunning = False
		self.inGame = False
		self.pid = None
		self.acceptHand = 0
		self.newTurn = 0
		self.searchSet = {'DestroyedMaterialIDs', 'ActionEndTurn'}
		_thread.start_new_thread(self.find_process, ())

	#First pass getting static decklist
	def get_current_deck(self):
		self.deck = api.get_static_deck()
		if(self.deck == None or self.deck == -1):
			self.get_current_deck()

		_thread.start_new_thread(self.get_current_hand, ())

	def get_current_hand(self):
		while True:
			if(self.inGame == False):
				return

			self.hand = api.get_current_cards()

			time.sleep(1)

	#Function will monitor the current player's state in game.  This could be them in menus, or in game etc
	#When the player is in progress.  This function will need to spawn a new thread to monitor the current active cards
	def get_game_state(self):
		while True:
			if(self.running == False):
				return 

			self.gameState = api.get_game_state()

			#First pass, initializing the game
			if(self.inGame == False and self.gameState == "InProgress"):
				self.inGame = True
				self.get_current_deck()
				_thread.start_new_thread(self.parse_logs, ())

			if(self.inGame == True and self.gameState != "InProgress"):
				self.inGame = False
				self.reset()

			time.sleep(1)

	#Once we have the PID of legends of runeterra we can use a shortcut to check if the process is still running
	def check_pid(self):
		while True:
			if psutil.pid_exists(self.pid):
			    pass
			else:
			    self.running = False;
			    self.logPath = None;
			    return

			time.sleep(1)

	#Thread to monitor the LoR.exe process.  Required to find the new log file generated by the game
	#First pass must find the pid.  We don't want to continously iterate over every process
	def find_process(self):
		path = "C:\\Users\\quinn\\AppData\\Local\\Riot Games\\Legends of Runeterra\\Logs\\"
		flag = False;
		for proc in psutil.process_iter():
		    if(proc.name() == 'LoR.exe'):
		    	flag = True;
		    	temp = proc.open_files()
		    	self.pid = proc.ppid()
		    	for x in temp:
		    		length = len(path)
		    		sub = x.path
		    		sub = sub[:length]
		    		if(sub == path and self.logPath == None):
		    			print("found log")
		    			self.logPath = x.path
		    			self.running = flag;
		    			_thread.start_new_thread(self.get_game_state, ())

		self.running = flag;

		#Log file is generated everytime a new instance of the app launches so reset when main process closes
		if(flag == False):
			self.logPath = None;
		else:
			self.check_pid()

		time.sleep(1)
		self.find_process()

	def parse_accept_hand(self, string):
		target = " OnGameActionSuccess: ActionAcceptHand"
		sub = string[:len(target)]

		if(sub == target):
			print("*********Player has Accepted Their Initial Hand*********")
			self.acceptHand += 1

	def parse_new_turn(self, string):
		target = " Cleaning up"
		sub = string[:len(target)]

		if(sub == target):
			#print("--------------------New Turn--------------------------")
			self.newTurn += 1

	#Function will tail the log file for every new input of data.  Currently searches for a new turn tell 
	def parse_logs(self):
		#Checking initial accept hand 
		self.acceptHand = 0
		self.newTurn = 0

		with open(self.logPath, 'r') as logFile:
			logFile.seek(0, 2)

			while True:
				#We want to kill the thread when the player isn't in a current game
				if(self.gameState != "InProgress"):
					return 

				line = logFile.readline()

				if not line:
					time.sleep(0.1)
					continue

				sub = re.sub(r'\([^()]*\)', '', line).rstrip()
				self.parse_new_turn(sub)
				self.parse_accept_hand(sub)
				

	def reset(self):
		self.deck = None
		self.hand = None

#Player no mulligan accepts game///THIS ALSO GETS CALLED ON redraws.  Once this has shown up we know the player has accepted their hand
#OnGameActionSuccess: ActionAcceptHand